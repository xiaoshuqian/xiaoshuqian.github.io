<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>
            FEC in NR and LTE
        </title>
    </head>
    <body>
        <h1>
            FEC in NR and LTE
        </h1>
        <h4>
            Reference textbook(s)
        </h4>
        <ul>
          <li><a href="https://www.sciencedirect.com/book/9780128143230/5g-nr#book-description">5G NR: The Next Generation Wireless Access Technology</a> from <a href=https://www.elsevier.com/books/5g-nr-the-next-generation-wireless-access-technology/dahlman/978-0-12-814323-0">Elsevier</a>
          </li>
          <li><a href="http://solutionsproj.net/software/Signal_Processing_for_5G_Algorithms_and_Implementations.pdf">SIGNAL PROCESSING FOR 5G</a> 
          </li>
          <li><a href="https://www.mathworks.com/videos/series/5g-explained.html">5G Explained</a> from mathworks
          </li>
          <li><a href=http://www.techplayon.com/wp-content/uploads/2018/09/5G-NR-Channels-Structures-600x332.png>Channel mapping</a>: logical, transport and physical (DL-SCH, UL-SCH: BBCH, CCCH, DCCH, DTCH)
          </li>
          <li><a href=http://www.techplayon.com/5g-nr-reference-signals-dmrs-ptrssrs-and-csi-rs/>RS</a>: DMRS, PTRS, CSI-RS and SRS
          </li>
          <li><a href=https://www.keysight.com/upload/cmc_upload/All/Understanding_the_5G_NR_Physical_Layer.pdf>NR-PHY</a> from Keysight
          </li>
          <li>Digital Communication 3rd Edition by John R. Barry, Edward A. Lee, David G. Messerschmitt
          </li>
          <li>David Forney
            <ul>
              <li><a href="https://web.stanford.edu/class/ee392d/">Stanford course</a>
              </li>
            </ul>
          </li>
        </ul>
        <h4>
            Description
        </h4>
        <p>
        </p>
        <h4>
            Detailed outline
        </h4>
<ul>
  <li>LTE DL-SCH transport layer: ABCDEFGK (Ref: Farooq Khan, 36.212)
    <ul>
      <li>Param
        <ul>
          <li>TB level param
            <ul>
              <li>TBS: as a function of I<sub>TBS</sub> and N<sub>PRB</sub>, see tables in 36.213
              </li>
              <li>G = TB output size = N<sub>PRB</sub> * 12 * 14 - CRE overhead - other potential overhead, possible overhead factor 0.82, 0.75, etc based on the googling on lte capacity calculation or REs used for data  
              </li>
              <li>N. layers, QAM order, rv
              </li>
            </ul>
          <li>Derived parameters
            <ul>
              <li>CB segmentation: Cp, Cm, Kp, Km: max K value = 6144, possible K values are 40+8t, 512+16t, 1024+32t, 2048+64t, see table in 36.212 of possible Quadrature Poly Interleaver Size
              </li>
              <li>Rate match: offset (2, 26, 50 or 74) as a fun of rv, Ep, Em, nEm as a fun of C, G, QAM order, N layers 
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>matlab code: see 5G/FEC/matlab/lte/DL-SCH tab
      </li>
      <li>A = TBS, B = A + L: TB CRC24A
      </li>
      <li>Segmentation and CB CRC: output is c<sub>r,j</sub>, K<sub>r</sub> is the output length per CB (K<sub>-</sub>, K<sub>+</sub>) 
        <ul>
          <li>if B &le; Z = 6144, L = 0, C = 1, B' = B
          </li>
          <li>OW, L=24, C = ceil(B / (Z - L)), B' = B + C*L
          </li>
          <li>K<sub>+</sub> is the smallest legal CB size such that K<sub>+</sub>C &ge; B'. The legal sizes supported in the QPP interleaver are (for non-negative integer t &le; 64)
              <ul>
                <li>40 + 8t, 512 + 16t, 1024 + 32t, 2048 + 64t for K &le; 512, 1024, 2048, 6144 respectively
                </li>
              </ul>
          </li>
          <li>K<sub>-</sub> is the largest CB size that is supported in the QPP interleaver such that K<sub>-</sub>C &lt; K<sub>+</sub>
          </li>
          <li>C = C<sub>+</sub> + C<sub>-</sub>, B' &le; C<sub>+</sub>K<sub>+</sub> + C<sub>-</sub>K<sub>-</sub> => C<sub>-</sub> = floor((CK<sub>+</sub> - B')/&Delta;), where &Delta = K<sub>+</sub> - K<sub>+</sub>
          </li>
          <li>F = C<sub>+</sub>K<sub>+</sub> + C<sub>-</sub>K<sub>-</sub> - B' is the number of filler (0) bits that will be placed at the begining of the TB and will be removed at the end of RM
          </li>
          <li>Shorter CBs, if any, with length K<sub>-</sub> will be placed before longer one with length K<sub>+</sub>
          </li>
        </ul>
      </li>
      <li>Turbo coding: output is d<sub>r,j</sub>, D<sub>r</sub> = K<sub>r</sub> + 4 = the output length per CB
        <ul>
          <li>15, 13: (1, (1 + D + D<sup>3</sup>)/ (1 + D<sup>2</sup> + D<sup>3</sup>))
          </li>
          <li>12 termination bits, 6 per constituent encoder, to zero out the encoder shift registers in 3 clock cycles
          </li>
        </ul>
      </li>
      <li>Rate matching: output is e<sub>r,j</sub>, E<sub>r</sub> is the output length per CB (E<sub>-</sub>, E<sub>+</sub>) 
        <ul>
          <li>Note
              <ul>
                  <li>Rate match is done per CB and scrambling and QAM modulation can also be done per CB with the possible exception of MIMO two codewords case (need to verify, see Farooq Khan) 
                  </li>
                  <li>Rate match output length for each CB (E<sub>-</sub>, E<sub>+</sub>) needs to be computed based on the total output length of the transport layer E
                  </li>
              </ul>
          </li>
          <li>Block interleaving and bit-reverse column permutation:
            <ul>
              <li>Circularly left-shift parity 2 bits by 1 bit.
              </li>
              <li>For each stream of encoder output (i.e. systematic, parity1 and parity2), write row-wise the encoder output to a 32 column matrix with dummy (0) bits prepended at the begining if needed (these will be removed at the RM output)
              </li>
              <li>Permutate the columns of the matrix using a bit-reversing order
              </li>
              <li>Write-out column-wise
              </li>
            </ul>
          </li>
          <li>Interlace the parity 1 and parity2 output
          </li>
          <li>Write it into a HARQ circular buffer of size Ncb (= 3*32*R by default for max coding rate 1/3)
              <ul>
                  <li>It's best to view the circular buffer as a 96 columns matrix (see sec 10.3.2.4 of Stefania Sesia et al.). The address of this buffer can be directly computed based on the index of the encoder output stream.
                  </li>
              </ul>
          </li>
          <li>Read it out from the HARQ circular buffer:
            <ul>
              <li>Compute the offset. With systematic bit puncturing and uniform spaced RVs, the offsets k0 start at the columns 2, 26, 50 and 74 for RVs j = 0, 1, 2, 3:
                <ul>
                  <li>Let 2*S = column spacing between two adjacent RVs and R = # of rows of the interleaver matrix. Then k0 = R * (2 + 2*S*j)
                  </li>
                  <li> S = ceil(N<sub>cb</sub>/8/R), where N<sub>cb</sub>/R = circular CB buffer size in columns
                  </li>
                  <li>If N<sub>cb</sub> = 3R*32, then  N<sub>cb</sub>/R = 96 and S = 12. Thus, k0 = R*(2, 26, 50, 74).
                  </li>
                </ul>
              </li>
              <li>Bit selection: E<sub>-</sub> = floor(G'/C)*QL, E<sub>+</sub> = ceil(G'/C)*QL, where
                <ul>
                  <li>G' = G/(QL) = total number of REs per layer at RM output for this TB
                  </li>
                  <li>Q, L = QAM order and number of layers respectively (for Alamouti code, L = 2)
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Concatenation: output is f<sub>j</sub>, G is the output length for the whole TB
      </li>
    </ul>
  </li>
  <li>NR DL-SCH transport channel: ABCDEFGK (Ref: 38.212)
    <ul>
      <li>Param
        <ul>
          <li>TB level param
            <ul>
              <li>TB length thresholds: A = 292, 3824
              </li>
            </ul>
          <li>Derived parameters
          </li>
        </ul>
      </li>
      <li>matlab code: see 5G/FEC/matlab tab
      </li>
      <li>A = TBS, B = A + L: TB CRC24A or CRC16. If A &le& 3824, L = 16, else L = 24
      </li>
      <li>Segmentation and CB CRC: output is c<sub>r,j</sub>, K = 22Zc and 10Zc are the output length per BG1 and BG2 CBs resp.
        <ul>
          <li>BG selection: BG 1 for long TB and high coding rate and BG2 for short TB and lower coding rate
              <ul>
                  <li>TB length thresholds: A = 292, 3824
                  </li>
                  <li>Coding rate thresholds: 1/4, 2/3
                  </li>
              </ul>
          </li>
          <li>Max CB length K<sub>cb</sub> selection: K<sub>cb</sub> = 8448 = 22*384 if BG1. K<sub>cb</sub> = 3840 = 10*384 if BG2
          </li>
          <li>Number of CBs and # of non-filler bits per TB
            <ul>
              <li>L = 0, C = 1, B' = B if B &le; K<sub>cb</sub>
              </li>
              <li>OW, L=24, C = ceil(B / (K<sub>cb</sub> - L)), B' = B + C*L
              </li>
              <li># of non-filler bits per CB: K' = B'/C
              </li>
            </ul>
          </li>
          <li>Select lifting size:
            <ul>
              <li>Select K<sub>b</sub>: K<sub>b</sub> = 22 for BG1. K<sub>b</sub> = 10, 9, 8, 6 for BG2 depending on TBS &gt; 640, &gt; 560, &gt; 192 or otherwise. 
              </li>
              <li>Lifting size Zc = smallest legal lifting size such that Z<sub>c</sub>K<sub>b</sub> &ge; K'
              </li>
            </ul>
          </li>
          <li>Number of bits per CB including filler bits, which are added after the CRC bits: K = 22Zc for BG1 and K = 10Zc for BG2
          </li>
        </ul>
      </li>
      <li>LDPC coding: output is d<sub>r,j</sub>, N = 66Zc and 50Zc are the output length per BG1 and BG2 CBs resp.
        <ul>
          <li>BG1 = ABCDE: A = 4 by 22, B = 4 by 4 (~ dual diagonal), C = 4 by 42 (= 68 - 26), D = 42 (68 - 22 - 4) by 26, E = 42 by 42 (diagonal). The first two columns are always punctured. Thus 20 systematic output columns at most. Lowest coding rate 1/3 (Thus, 22 message columns are transmitted using 22*3 = 66 coded columns)
          </li>
          <li>BG2 = ABCDE: A = 4 by 10, B = 4 by 4 (~ dual diagonal), C = 4 by 38 (= 52 - 14), D = 38 (52 - 10 - 4) by 14, E = 38 by 38 (diagonal). The first two columns are always punctured. Thus 20 systematic output columns at most. Lowest coding rate = 1/5 (Thus, 10 message columns are transmitted using 10*5 = 50 coded columns)
          </li>
        </ul>
      </li>
      <li>Rate matching = selection + intereaving: output is e<sub>r,j</sub>, E is the output length per CB
        <ul>
          <li>Note
              <ul>
                  <li>Rate match is done per CB and scrambling and QAM modulation can also be done per CB with the possible exception of MIMO two codewords case (need to verify, see 38.212) 
                  </li>
                  <li>Rate match output length for each CB (E<sub>-</sub>, E<sub>+</sub>) needs to be computed based on the total output length of the transport layer E
                  </li>
              </ul>
          </li>
          <li>For each stream of encoder output (i.e. systematic, parity1 and parity2), write row-wise the encoder output to a 32 column matrix with dummy (0) bits prepended at the begining if needed (these will be removed at the RM output)
          </li>
          <li>Permutate the columns of the matrix using a bit-reversing order
          </li>
          <li>Write-out column-wise
          </li>
          <li>Interlace the parity 1 and parity2 output
          </li>
          <li>Write it into a circular buffer
              <ul>
                  <li>It's best to view the circular buffer as a 96 columns matrix (see sec 10.3.2.4 of Stefania Sesia et al.). The address of this buffer can be directly computed based on the index of the encoder output stream.
                  </li>
              </ul>
          </li>
          <li>Interleaving: write row-wise and read column-wise, # of rows = QAM order, Thus, the systematic bits will be the most significant QAM bits and will be more reliable.
          </li>
        </ul>
      </li>
      <li>Concatenation: output is f<sub>j</sub>, G is the output length for the whole TB
      </li>
    </ul>
  </li>
  <li>NR transport layer
  </li>
  <li>Polar encoding
    <ul>
      <li><a href="https://arxiv.org/pdf/1507.05138.pdf">MIMO detection</a>
        <ul>
          <li>ZF
          </li>
          <li>MMSE
          </li>
          <li>Sphere-decoding: Tree Search Detection (TSD)
            <ul>
              <li>QR Decomponsition pre-processing: GS, Modified GS, Householder
              </li>
              <li>Traditional <a href="https://www.researchgate.net/publication/3236239_Algorithm_and_implementation_of_the_K-best_Sphere_decoding_for_MIMO_detection">K-best search</a> (problems to be solved at each layer): Additive distance metric, Manhattan (L1) norm, addressing missing counter-hypothesis
              </li>
              <li>Reduced complexity methods<a href="https://ieeexplore.ieee.org/abstract/document/5661890">I</a>, <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6200359">II</a> (again focus on problems to be solved at each layer)
                <ul>
                  <li>Slicing to obtain inherited best candidate
                  </li>
                  <li>Best candidate's sibling, <a href="https://link.springer.com/article/10.1007/BF01581144">1D Schnorr-Euchner (SE) enumeration</a> (see picture <a href="https://www.researchgate.net/publication/281472406_Algorithms_and_architectures_for_the_detection_of_MIMO_signals?enrichId=rgreq-ae8f00c368976f9adf5df194d66991ef-XXX&enrichSource=Y292ZXJQYWdlOzI4MTQ3MjQwNjtBUzoyOTkyNTg4ODU0OTI3NDJAMTQ0ODM2MDI4NjYxMA%3D%3D&el=1_x_3&_esc=publicationCoverPdf">here</a>)
                  </li>
                </ul>
              </li>
              <li>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Polar decoding
  </li>
  <li>LDPC encoding
    <ul>
      <li>Parallel concatenated Turbo code
      </li>
      <li>Turbo block code
      </li>
      <li>Serial concatenated Turbo code
      </li>
      <li>RA (Repeat-Accumulator)
      </li>
        <ul>
          <li>Regular
          </li>
          <li>Irregular
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>LDPC decoding
  </li>
</ul>
    </body>
</html>
