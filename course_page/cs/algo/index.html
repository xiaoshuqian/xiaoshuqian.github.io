<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>
            Algorithms
        </title>
    </head>
    <body>
        <h1>
            Algorithms
        </h1>
        <h2>
            Quarter offered
        </h2>
        <p>
        </p>
        <h2>
            Course description
        </h2>
        <h4>
            Instructor
        </h4>
        <p>
        Dr. Xiaoshu Qian
        </p>
        <h4>References
        </h4>
        <ul>
          <li><a href="https://introcs.cs.princeton.edu/java/home/">Sedgewick & Wayne at Princeton</a> (See also <a href="http://www.cs.princeton.edu/~rs/">Sedgewick</a>):
            <ul>
              <li><a href="https://algs4.cs.princeton.edu/cheatsheet/">Cheat Sheet</a> for algorithms and data structures
              </li>
              <li><a href="https://introcs.cs.princeton.edu/java/11cheatsheet/">Java cheat sheet</a>
              </li>
              <li>books: Java, computer science, algorithms, analysis of algorithm, analytic combinatorics
              </li>
              <li>Online/coursera courses: Computer Science: Programming with a Purpose, algorithms I/II, analytic combinatorics
              </li>
              <li><a href="https://introcs.cs.princeton.edu/java/assignments/">Programming assignments</a>: <a href="https://coursera.cs.princeton.edu/introcs/assignments/">a good subset</a>
            </ul>
          </li>
          <li><a href="http://jeffe.cs.illinois.edu/teaching/algorithms/">Algorithms</a> by Jeff Erickson
          </li>
          <li>Stanford:
            <ul>
              <li><a href="https://web.stanford.edu/class/cs97si/07-shortest-path-algorithms.pdf">shortest path algorithms</a> by Prof. Jaehyun Park
              </li>
            </ul>
          </li>
        </ul>
        <h4>
            Description
        </h4>
        <p>
        From ITU course catalog: Emphasizes principles of software development, style, and testing. Topics include procedures and functions, iteration, recursion, arrays and vectors, strings, an operational model of procedure and function calls, algorithms, exceptions, object-oriented programming.
        </p>
        <h4>
            Detailed outline
        </h4>
<ul>
  <li>Overview
    <ul>
      <li>Key concepts in problem solving: bottom-up (smallest problem first), top-down/recursion, search tree, info encapsulation/memory, data structure & ADT, invariance, state-machine
      </li>
      <li>Problem solving strategies
        <ol>
          <li>Exhaustive search: n-queen, assignment 
          </li>
          <li>Decrease-n-conquer, divide-n-conquer, transform-n-conquer or reduction
          </li>
          <li>Greedy: MST
          </li>
          <li>Two general strategies: dynamic programming and linear programming
          </li>
          <li>Back-tracking, branch & bound: n-queen, assignment, Hamiltonian circuit
          </li>
          <li>Uninformed/informed search
          </li>
          <li>Iterative-improvement: network flow, linear programming
          </li>
          <li>Space-time trade-off: two-sum, three-sum, weighted union-find, stack with max
          </li>
        </ol>
      </li>
      <li>Problem solving steps
        <ul>
          <li>Understanding the problem, starting with the small problems
          </li>
          <li>Design and implementing an algorithm to solve the probelm
          </li>
          <li>Testing and debugging
            <ul>
              <li>Implementing an additional naive/safe/ref algorithm
              </li>
              <li>Create a random test generator: test case and data
              </li>
              <li>Create a infinite loop that will
                <ul>
                  <li>generate a random test case
                  </li>
                  <li>feed the test input to both the ref algorithm and the target algorithm and compare the results
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Ways to practice coding:
        <ol>
          <li>using examples based the problem solving strategies
          </li>
          <li>using examples from ADT, sorting, search, graph and string algorithms
          </li>
          <li>using online coding challenges
          </li>
        </ol>
      </li>
    </ul>
  </li>
  <li>Data structure and ADT
    <ul>
      <li>List: array and linked list representation
      </li>
      <li>Stack
      </li>
      <li>Queue
      </li>
      <li>Set
      </li>
      <li>Map/dict
      </li>
      <li>Priority queue and Indexed PQ
      </li>
    </ul>
  </li>
  <li>Sorting
    <ul>
      <li>Selection
      </li>
      <li>Insertion
      </li>
      <li>Quick
      </li>
      <li>Merge
      </li>
      <li>Bubble
      </li>
      <li>Shell
      </li>
    </ul>
  </li>
  <li>Searching/symbol table
    <ul>
      <li>Array: sorted, unsorted
      </li>
      <li>BST
      </li>
      <li>Balanced ST
        <ul>
          <li>2-3 tree
          </li>
          <li>Red-black
          </li>
          <li>AVL
          </li>
          <li>B-tree
          </li>
        </ul>
      </li>
      <li>Hashing
      </li>
    </ul>
  </li>
  <li>Graph
    <ul>
      <li>Representation, I/F
      </li>
      <li>DFS, BFS for graph and digraph
      </li>
      <li>Connected and strongly connected components
      </li>
      <li>MST
      </li>
      <li>Shortest path: Dijkstra, Bellman-Ford, Bellman for DAG, Floyd-Warshall
      </li>
      <li>Maximum flows and minimum cuts
      </li>
    </ul>
  </li>
  <li>String
    <ul>
      <li>Sorting
      </li>
      <li>Searching with tries
      </li>
      <li>Matching
        <ul>
          <li>Brute-force, with or without backtracking
          </li>
          <li>Knuth-Morris-Pratt
          </li>
          <li>Boyer-Moore: Huristic, starting from the last symbol
          </li>
          <li>Rabin-Karp: Modular hashing
          </li>
        </ul>
      </li>
      <li>Regular expression
        <ul>
          <li>DFA and NFA definitions and representations
          </li>
          <li>NFA simulation
          </li>
          <li>NFA construction
          </li>
          <li>Applications: A fundamental paradigm in CS used in KMP, grep, Java (they have an underlying pattern (or/and a grammer), a parser to check syntax errors (not needed in KMP), a compiler, and a simulator):
            <ul>
              <li>Pick an intermediate abstraction (e.g. DFA, NFA, byte code)
              </li>
              <li>Build a compiler that transforms problems into this intermediate abstraction (e.g. output of the compiler can be DFA, NFA, byte code, or a pattern from java.util.regex.Pattern)
              </li>
              <li>Build a simulator that 'implements' this intermediate abstraction using a lower level abstraction/machine (i.e. make the abstraction concrete. e.g. JVM, a matcher of type java.util.regex.Matcher)
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Data compression
      </li>
    </ul>
  </li>
  <li>Reduction and complexity theory
  </li>
  <li>Linear programming
  </li>
</ul>
    </body>
</html>
